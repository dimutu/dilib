
/*
*********************************************************************************************************************************************
*
* Author: Dimutu Kulawardana
* Date: 28-05-2011
* Description: template class gets to implement a single task that executed by a player,		
*		** NOTE THAT THIS IS JUST A TEMPLATE THAT HAS TO IMPLEMENT TO EACH TASK SO THE FUNCTION BODIES HERE ARE ONLY TO EXPLAIN HOW THE FUNCTION
*			WORKS!!!**
*
*********************************************************************************************************************************************
*/


#ifndef _DI_TASK_H_
#define _DI_TASK_H_

#include <string>
#include "DiBase.h"


//! \details Main library namespace

//! \namespace DiLib
namespace DiLib
{
	//! \class DiTask
	//! \details Template class gets to implement a single task that executed in the tree,
	//!< this act as the leaf node of the tree and base class for all other tasks.
	//! \par This class must be implemented in the game code in-order to use it.
	template <class T>
	class DiTask : public DiBase
	{
	public:
		//! Constructor
		DiTask();

		//! Virtual destructor
		virtual ~DiTask();

		//! Load an external script using the given file, this gets parameter value set from the UI during the loading process of the tree and sets m_zScriptFile.
		//! \par Function must be overriden in-order to set the rest of the process of opening and executing the selected scrip file 
		//! \param[in] a_zScriptFile Script file path set's through the tree creation interface
		//! \return bool For extending purposes to evaluate loading success or failure.
		virtual bool LoadScript(const char* a_zScriptFile);

		//! Reload the current script to update script modification.
		//! \par Function must be overriden in-order to use the features.
		virtual void ReloadScript(); 

		//! Execute the task on this template type, either using loaded script or the code set in the implemented class
		//! \par This is a pure virtual function to be used on extended classes.
		//! \param a_pkOwner Template class that this task to be executed upon.
		//! \return Integer to evaluate the new state of the template class or the AI object
		//!< This is more efficiently described through DI_TASK_RETURNS enumeration generated by the DiParser when \link setup_cpp Setting up C++ project \endlink
		virtual int Execute(T* a_pkOwner) = 0;

		//! Get the parent of this task
		//! \return DiTask<T>* Pointer to parent task
		DiTask<T>* GetParent() const;

		//! Set the parent node. This gets called through DiFactory during tree initialization
		//! \param a_pkParentTask Pointer reference of the parent task
		void SetParent(const DiTask<T>* a_pkParentTask);

		//! Set the pointer reference to root node
		//! \param a_pkRoot Pointer reference to the root task
		void SetRoot(const DiRoot<T>* a_pkRoot);

		//! Set additional arguments need for this task set from the UI
		//! \param a_zArgs Argument value in a string
		void SetArgs(const char* a_zArgs);

	protected:
		const DiRoot<T>* m_pkRoot; //!< Pointer to the DiRoot task

		const DiTask* m_pkParentTask; //!< Pointer to the parent task

		std::string m_zScriptFile; //!< External script file path (To be use by implementation)

		std::string m_zArgs; //!< Additional arguments to pass-in from the UI to use inside this task
	};
	//***************************************************************************************************************************************************//
}

#endif



