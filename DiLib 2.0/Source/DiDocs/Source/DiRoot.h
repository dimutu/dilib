
/*
*********************************************************************************************************************************************
*
* Author: Dimutu Kulawardana
* Date: 06-06-2011
* Description: the behaviour tree root node, this will keep track of all the task nodes in the tree, handles the memory and reloading scripts
*
*********************************************************************************************************************************************
*/

#ifndef _DI_ROOT_TREE_H_
#define _DI_ROOT_TREE_H_

#include "DiSelection.h"

//! \details Main library namespace

//! \namespace DiLib
namespace DiLib
{
	//! \class DiRoot
	//! \details The behaviour tree root node, this will keep track of all the task nodes in the tree, handles the memory and reloading scripts
	template <class T>
	class DiRoot : public DiSelection<T>
	{
	public:
	
		//! Constructor
		DiRoot();

		//! Virtual destructor, remove the root and its child nodes and free the memory used
		virtual ~DiRoot();

		//! Execute each task as DiSelection or can be override to change the order
		//! \param a_pkOwner Template class that this task to be executed upon.
		//! \return Integer to evaluate the new state of the template class or the AI object
		//!< This is more efficiently described through DI_TASK_RETURNS enumeration generated by the DiParser when \link setup_cpp Setting up C++ project \endlink

		virtual int Execute(T* a_pkOwner);

		//! add new child node to task list, this is to keep track of all the child nodes in the tree, and for memory management
		//! \param a_pkNode Child node
		void AddTaskNode(DiTask<T>* a_pkNode);

		//! This is to keep track of scriptable nodes in the root, not for memory management,
		//!< but to reload scripts to update these tasks without exiting the program
		//! \param a_pkNode Child node, that has exteral scripting
		void AddScriptNode(DiTask<T>* a_pkNode); 

		//! Clean up all memory, using the task node list and deleting all of it
		void ClearAll(); 

		//! To be implemented if needs to reload the scripts nodes and doesnt have to go through all the nodes
		virtual void ReloadScripts();

		//! For extending purpose, keep track of last task if need to avoid executing whole tree
		virtual void SetLastTask(const DiTask* a_pkTask);

	protected:
		const DiTask<T>* m_pkLastTask; //!< Keep track of last task if need to avoid executing whole tree

		std::vector< DiTask<T>* > m_akTreeNodesList; //!< All the nodes belongs to this tree root

		std::vector< DiTask<T>* > m_akScriptNodeList; //!< The nodes that have scripts, so running through this node list can reload its scripts

	};
	//***************************************************************************************************************************************************//

}
#endif


