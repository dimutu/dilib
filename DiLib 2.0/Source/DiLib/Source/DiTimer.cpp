
/*
*********************************************************************************************************************************************
*
* Author: Dimutu Kulawardana
* Date: 28-05-2011
* Description: timer class to help execute code in time intervals
*
*********************************************************************************************************************************************
*/

#include "DiTimer.h"

namespace DiLib
{
	/*
	********************************************************************************************************************************************
	* Function: DiTimer() - constructor
	* Parameters: none
	* Return: none
	********************************************************************************************************************************************
	*/
	DiTimer::DiTimer()
	{
		m_uiTimeInterval = 0;
		CaclNextRunTime();
	}


	/*
	********************************************************************************************************************************************
	* Function: DiTimer() - constructor
	* Parameters: const unsigned int a_uiTimeInterval - time interval for the timer 
	* Return: none
	********************************************************************************************************************************************
	*/
	DiTimer::DiTimer(const unsigned int a_uiTimeInterval)
	{
		m_uiTimeInterval = a_uiTimeInterval;
		CaclNextRunTime();
	}
	/*******************************************************************************************************************************************/

	/*
	********************************************************************************************************************************************
	* Function: ~DiTimer() - destructor
	* Parameters: none
	* Return: none
	********************************************************************************************************************************************
	*/
	DiTimer::~DiTimer()
	{
	}
	/*******************************************************************************************************************************************/

	/*
	********************************************************************************************************************************************
	* Function: SetTimeInterval() - set a new time interval
	* Parameters: const unsigned int a_uiTimeInterval - time interval for the timer 
	* Return: void
	********************************************************************************************************************************************
	*/
	void DiTimer::SetTimeInterval(const unsigned int a_uiTimeInterval)
	{
		m_uiTimeInterval = a_uiTimeInterval;
		CaclNextRunTime();
	}
	/*******************************************************************************************************************************************/

	/*
	********************************************************************************************************************************************
	* Function: GetTimeInterval() - get current time interval
	* Parameters: void
	* Return: const unsigned int a_uiTimeInterval
	********************************************************************************************************************************************
	*/
	unsigned int DiTimer::GetTimeInterval() const
	{
		return m_uiTimeInterval;
	}
	/*******************************************************************************************************************************************/

	/*
	********************************************************************************************************************************************
	* Function: IsRunTime() - checks currently passed or at next execution time, and if so calculate next again
	* Parameters: none
	* Return: bool - given time interval is passed (true) or pending(false)
	********************************************************************************************************************************************
	*/
	bool DiTimer::IsRunTime() const //checks currently passed or at next execution time, and if so calculate next again
	{
		clock_t cur = clock();
		return ( m_lNextRunTime <= cur );
	}
	/*******************************************************************************************************************************************/

	/*
	********************************************************************************************************************************************
	* Function: CaclNextRunTime() - calculate next run time
	* Parameters: none
	* Return: void
	********************************************************************************************************************************************
	*/
	void DiTimer::CaclNextRunTime()
	{
		m_lLastRunTime = clock();
		m_lNextRunTime =m_lLastRunTime + m_uiTimeInterval;
	}
	/*******************************************************************************************************************************************/

	/*
	********************************************************************************************************************************************
	* Function: SetNextTimeInterval() - set the time to next time interval using current interval, so have a repeat effect
	* Parameters: none
	* Return: void
	********************************************************************************************************************************************
	*/
	void DiTimer::SetNextTimeInterval()
	{
		CaclNextRunTime();
	}
	/*******************************************************************************************************************************************/
}
